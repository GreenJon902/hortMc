#version 460 core
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct CameraIn {  // For getting the data to us
    float x;
    float y;
    float z;
    float yaw;
    float pitch;
    float roll;
    int fov;
};

struct Camera {  // For actual use of camera
    ivec2 image_size;
    mat3 rotation_matrix;
    vec3 forward;
    vec3 right;
    vec3 up;
    float image_plane_distance;
};

struct Ray {  // We store rays as an x coordinate and 2 line equations - z = my * x + cy, y = mz * x + cz
    vec3 pos;

    float my;  // Gradient in the y plane                              //  Calculate z from x value
    float cy;  // Y intercept in the y plane (the y position at 0, 0)  //  /
    float mz;                                                          //  Calculater y from x value
    float cz;                                                          //  /
};

layout(std430, binding = 0) buffer CameraBuffer {
    CameraIn camera;
} IN;

writeonly uniform image2D outputTexture;


Camera make_camera() {  // From IN.camera
    ivec2 image_size = ivec2(gl_NumWorkGroups.xy);

    float yaw = radians(IN.camera.yaw);
    float pitch = radians(IN.camera.pitch);
    float roll = radians(IN.camera.roll);
    float cosYaw = cos(yaw);
    float sinYaw = sin(yaw);
    float cosPitch = cos(pitch);
    float sinPitch = sin(pitch);
    float cosRoll = cos(roll);
    float sinRoll = sin(roll);

    mat3 rotation_matrix;
    rotation_matrix[0][0] = cosYaw * cosRoll + sinYaw * sinPitch * sinRoll;
    rotation_matrix[0][1] = sinRoll * cosPitch;
    rotation_matrix[0][2] = -sinYaw * cosRoll + cosYaw * sinPitch * sinRoll;

    rotation_matrix[1][0] = -cosYaw * sinRoll + sinYaw * sinPitch * cosRoll;
    rotation_matrix[1][1] = cosRoll * cosPitch;
    rotation_matrix[1][2] = sinYaw * sinRoll + cosYaw * sinPitch * cosRoll;

    rotation_matrix[2][0] = sinYaw * cosPitch;
    rotation_matrix[2][1] = -sinPitch;
    rotation_matrix[2][2] = cosYaw * cosPitch;



    vec3 forward = rotation_matrix * vec3(0.0, 0.0, 1.0);
    vec3 right = rotation_matrix * vec3(1.0, 0.0, 0.0);
    vec3 up = cross(forward, right);
    float image_plane_distance = image_size.y / (2.0 * tan(radians(float(IN.camera.fov)) / 2.0));

    return Camera(image_size, rotation_matrix, forward, right, up, image_plane_distance);
}


void main() {
    Camera camera = make_camera();
    ivec2 image_pixel_position = ivec2(gl_GlobalInvocationID.xy);  // Our position on image in pixels

    vec3 ray_direction = normalize(camera.forward * camera.image_plane_distance  // In view space
        + (float(image_pixel_position.x) - camera.image_size.x / 2.0) / camera.image_size.y * camera.right * camera.image_plane_distance
        + (float(image_pixel_position.y) - camera.image_size.y / 2.0) / camera.image_size.y * camera.up * camera.image_plane_distance);
    ray_direction = camera.rotation_matrix * ray_direction;  // Move to world space
    ray_direction = normalize(ray_direction);

    imageStore(outputTexture, image_pixel_position, vec4(ray_direction, 1));
}