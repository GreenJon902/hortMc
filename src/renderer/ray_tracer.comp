#version 460 core
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct Camera {  // For actual use of camera
    vec3 pos;
    ivec2 image_size;
    mat3 rotation_matrix;
    vec3 forward;
    vec3 right;
    vec3 up;
    float image_plane_distance;
};

struct Ray {
    vec3 pos;
    vec3 dir;
};

layout (std140) uniform CameraBlock {
    vec3 camera_pos;
    mat3 camera_rot_mat;
    int fov;
} IN;

writeonly uniform image2D outputTexture;


Camera make_camera() {  // From IN
    ivec2 image_size = ivec2(gl_NumWorkGroups.xy);
    vec3 forward = IN.camera_rot_mat * vec3(0.0, 0.0, 1.0);
    vec3 right = IN.camera_rot_mat * vec3(1.0, 0.0, 0.0);
    vec3 up = IN.camera_rot_mat * vec3(0.0, 1.0, 0.0);
    float image_plane_distance = image_size.y / (2.0 * tan(radians(float(IN.fov)) / 2.0));

    return Camera(IN.camera_pos, image_size, IN.camera_rot_mat, forward, right, up, image_plane_distance);
}



Ray make_ray(Camera camera, ivec2 image_pixel_position) {
    vec3 ray_direction = normalize(camera.forward * camera.image_plane_distance  // In view space
        + (float(image_pixel_position.x) - camera.image_size.x / 2.0) / camera.image_size.y * camera.right * camera.image_plane_distance
        + (float(image_pixel_position.y) - camera.image_size.y / 2.0) / camera.image_size.y * camera.up * camera.image_plane_distance);
    ray_direction = camera.rotation_matrix * ray_direction;  // Move to world space
    ray_direction = normalize(ray_direction);
    return Ray(camera.pos, ray_direction);
}

float min3(vec3 v) {
    return min(min(v.x, v.y), v.z);
}

bool hasInteger(vec3 v) {
    return any(equal(fract(v), vec3(0.0)));
}

#define epsilon 0.0001

Ray step_block(Ray ray) {
    if (hasInteger(ray.pos)) {
        ray.pos += ray.dir * epsilon;
    }

    while (!hasInteger(ray.pos)) {
        float x = ray.pos.x;
        float y = ray.pos.y;
        float z = ray.pos.z;
        float dx = ray.dir.x;
        float dy = ray.dir.y;
        float dz = ray.dir.z;
        vec3 times = vec3(dx > 0 ? ((ceil(x) - x) / dx) : ((x - floor(x)) / abs(dx)),
                          dy > 0 ? ((ceil(y) - y) / dy) : ((y - floor(y)) / abs(dy)),
                          dz > 0 ? ((ceil(z) - z) / dz) : ((z - floor(z)) / abs(dz)));
        float time = min3(times);
        ray.pos += ray.dir * time;
    }

    return ray;
}

bool collideXFace(vec3 v, float x, float y, float z) {
    return v.x == x && y < v.y && v.y < (y + 1) && z < v.z && v.z < (z + 1);
}

bool collideYFace(vec3 v, float x, float y, float z) {
    return x < v.x && v.x < (x + 1) && v.y == y && z < v.z && v.z < (z + 1);
}

bool collideZFace(vec3 v, float x, float y, float z) {
    return x < v.x && v.x < (x + 1) && y < v.y && v.y < (y + 1) && v.z == z;
}


void main() {
    ivec2 image_pixel_position = ivec2(gl_GlobalInvocationID.xy);  // Our position on image in pixels

    Camera camera = make_camera();
    Ray ray = make_ray(camera, image_pixel_position);

    for (int i=0; i<10; i++) {
        ray = step_block(ray);
        if (collideXFace(ray.pos, 2, 1, 5) || collideYFace(ray.pos, 2, 1, 5) || collideZFace(ray.pos, 2, 1, 5)) {
            imageStore(outputTexture, image_pixel_position, vec4(1, 0, 0, 1));
            break;
        } else {
            imageStore(outputTexture, image_pixel_position, vec4(0, 0, 0, 1));
        }
    }
}