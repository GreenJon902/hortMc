#version 460 core
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct Camera {  // For actual use of camera
    vec3 pos;
    ivec2 image_size;
    mat3 rotation_matrix;
    vec3 forward;
    vec3 right;
    vec3 up;
    float image_plane_distance;
};

struct Ray {  // We store rays as an x coordinate and 2 line equations - z = my * x + cy, y = mz * x + cz
    vec3 pos;
    vec3 dir;
};

layout(std430) buffer CameraBuffer {
    float x;
    float y;
    float z;
    float yaw;
    float pitch;
    float roll;
    int fov;
} IN;

writeonly uniform image2D outputTexture;


mat3 make_yaw_pitch_roll_matrix(float yaw, float pitch, float roll) {
    yaw = radians(yaw);
    pitch = radians(pitch);
    roll = radians(roll);
    float cosYaw = cos(yaw);
    float sinYaw = sin(yaw);
    float cosPitch = cos(pitch);
    float sinPitch = sin(pitch);
    float cosRoll = cos(roll);
    float sinRoll = sin(roll);

    mat3 rotation_matrix;
    rotation_matrix[0][0] = cosYaw * cosRoll + sinYaw * sinPitch * sinRoll;
    rotation_matrix[0][1] = sinRoll * cosPitch;
    rotation_matrix[0][2] = -sinYaw * cosRoll + cosYaw * sinPitch * sinRoll;

    rotation_matrix[1][0] = -cosYaw * sinRoll + sinYaw * sinPitch * cosRoll;
    rotation_matrix[1][1] = cosRoll * cosPitch;
    rotation_matrix[1][2] = sinYaw * sinRoll + cosYaw * sinPitch * cosRoll;

    rotation_matrix[2][0] = sinYaw * cosPitch;
    rotation_matrix[2][1] = -sinPitch;
    rotation_matrix[2][2] = cosYaw * cosPitch;

    return rotation_matrix;
}


Camera make_camera() {  // From IN
    ivec2 image_size = ivec2(gl_NumWorkGroups.xy);

    mat3 rotation_matrix = make_yaw_pitch_roll_matrix(IN.yaw, IN.pitch, IN.roll);
    vec3 forward = rotation_matrix * vec3(0.0, 0.0, 1.0);
    vec3 right = rotation_matrix * vec3(1.0, 0.0, 0.0);
    vec3 up = rotation_matrix * vec3(0.0, 1.0, 0.0);
    float image_plane_distance = image_size.y / (2.0 * tan(radians(float(IN.fov)) / 2.0));

    return Camera(vec3(IN.x, IN.y, IN.z), image_size, rotation_matrix, forward, right, up, image_plane_distance);
}

Ray make_ray(Camera camera, ivec2 image_pixel_position) {
    vec3 ray_direction = normalize(camera.forward * camera.image_plane_distance  // In view space
        + (float(image_pixel_position.x) - camera.image_size.x / 2.0) / camera.image_size.y * camera.right * camera.image_plane_distance
        + (float(image_pixel_position.y) - camera.image_size.y / 2.0) / camera.image_size.y * camera.up * camera.image_plane_distance);
    ray_direction = camera.rotation_matrix * ray_direction;  // Move to world space
    ray_direction = normalize(ray_direction);
    return Ray(camera.pos, ray_direction);
}

float min3(vec3 v) {
    return min(min(v.x, v.y), v.z);
}


int step_block(Ray ray) {  // We check if floored values before and after movement are different (new block / integer)
                           // Returns -1 for no collission, 0 for x, 1 for y, and 2 for z
    vec3 int_before_pos = floor(ray.pos);
    vec3 after_pos = ray.pos + ray.dir;
    vec3 int_after_pos = floor(after_pos);

    vec3 distance_multipliers = round(after_pos) - ray.pos; // Distance multipliers for each movement
    float smallest_disntance_mutliplier = min3(distance_multipliers);

    int collision_side;
    if (int_before_pos.x != int_after_pos.x && smallest_disntance_mutliplier == distance_multipliers.x) {
        collision_side = 0;
    } else if (int_before_pos.y != int_after_pos.y && smallest_disntance_mutliplier == distance_multipliers.y) {
        collision_side = 1;
    } else if (int_before_pos.z != int_after_pos.z && smallest_disntance_mutliplier == distance_multipliers.z) {
        collision_side = 2;
    } else {
        collision_side = -1;
        smallest_disntance_mutliplier = 1; // Step the ray by its entire movement
    }
}

void main() {
    ivec2 image_pixel_position = ivec2(gl_GlobalInvocationID.xy);  // Our position on image in pixels

    Camera camera = make_camera();
    Ray ray = make_ray(camera, image_pixel_position);

    imageStore(outputTexture, image_pixel_position, vec4(fract(3.1), 0, 0, 1));
}