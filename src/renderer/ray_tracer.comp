#version 460 core
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct CameraIn {  // For getting the data to us
    float x;
    float y;
    float z;
    float yaw;
    float pitch;
    float roll;
    int fov;
};

struct Camera {  // For actual use of camera
    ivec2 image_size;
    mat3 rotation_matrix;
    vec3 forward;
    vec3 right;
    vec3 up;
    float image_plane_distance;
};

struct Ray {  // We store rays as an x coordinate and 2 line equations - z = my * x + cy, y = mz * x + cz
    vec3 pos;

    float my;  // Gradient in the y plane                              //  Calculate z from x value
    float cy;  // Y intercept in the y plane (the y position at 0, 0)  //  /
    float mz;                                                          //  Calculater y from x value
    float cz;                                                          //  /
};

layout(std430, binding = 0) buffer CameraBuffer {
    CameraIn camera;
} IN;

writeonly uniform image2D outputTexture;


Camera make_camera() {  // From IN.camera
    ivec2 image_size = ivec2(gl_GlobalInvocationID.xy);
    mat3 rotation_matrix = mat3(
        vec3(cos(radians(IN.camera.yaw)) * cos(radians(IN.camera.pitch)),
             sin(radians(IN.camera.yaw)) * cos(radians(IN.camera.pitch)),
             -sin(radians(IN.camera.pitch))),
        vec3(cos(radians(IN.camera.yaw)) * sin(radians(IN.camera.pitch)) * sin(radians(IN.camera.roll)) - sin(radians(IN.camera.yaw)) * cos(radians(IN.camera.roll)),
             sin(radians(IN.camera.yaw)) * sin(radians(IN.camera.pitch)) * sin(radians(IN.camera.roll)) + cos(radians(IN.camera.yaw)) * cos(radians(IN.camera.roll)),
             cos(radians(IN.camera.pitch)) * sin(radians(IN.camera.roll))),
        vec3(cos(radians(IN.camera.yaw)) * sin(radians(IN.camera.pitch)) * cos(radians(IN.camera.roll)) + sin(radians(IN.camera.yaw)) * sin(radians(IN.camera.roll)),
             sin(radians(IN.camera.yaw)) * sin(radians(IN.camera.pitch)) * cos(radians(IN.camera.roll)) - cos(radians(IN.camera.yaw)) * sin(radians(IN.camera.roll)),
             cos(radians(IN.camera.pitch)) * cos(radians(IN.camera.roll)))
    );
                        rotation_matrix = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);

    vec3 forward = rotation_matrix * vec3(0.0, 0.0, 1.0);
    vec3 right = rotation_matrix * vec3(1.0, 0.0, 0.0);
    vec3 up = cross(forward, right);
    float image_plane_distance = image_size.y / (2.0 * tan(radians(float(IN.camera.fov)) / 2.0));

    return Camera(image_size, rotation_matrix, forward, right, up, image_plane_distance);
}


void main() {
    Camera camera = make_camera();
    ivec2 image_pixel_position = ivec2(gl_GlobalInvocationID.xy);  // Our position on image in pixels

    vec3 ray_direction = normalize(camera.forward * camera.image_plane_distance  // In view space
        + (float(image_pixel_position.x) - camera.image_size.x / 2.0) / camera.image_size.y * camera.right * camera.image_plane_distance
        + (float(image_pixel_position.y) - camera.image_size.y / 2.0) / camera.image_size.y * camera.up * camera.image_plane_distance);
    ray_direction = camera.rotation_matrix * ray_direction;  // Move to world space
    ray_direction = normalize(ray_direction);

    imageStore(outputTexture, image_pixel_position, vec4(ray_direction.z, 0, 0, 1));
}